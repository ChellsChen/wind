!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
ADDR_IP_LEN	vuirpc.h	14;"	d
AE_ALL_EVENTS	rnetwork/ae.h	46;"	d
AE_DONT_WAIT	rnetwork/ae.h	47;"	d
AE_ERR	rnetwork/ae.h	38;"	d
AE_FILE_EVENTS	rnetwork/ae.h	44;"	d
AE_NOMORE	rnetwork/ae.h	49;"	d
AE_NONE	rnetwork/ae.h	40;"	d
AE_NOTUSED	rnetwork/ae.h	52;"	d
AE_OK	rnetwork/ae.h	37;"	d
AE_READABLE	rnetwork/ae.h	41;"	d
AE_TIME_EVENTS	rnetwork/ae.h	45;"	d
AE_WRITABLE	rnetwork/ae.h	42;"	d
AF_LOCAL	rnetwork/anet.h	43;"	d
AL_START_HEAD	rlist/adlist.h	90;"	d
AL_START_TAIL	rlist/adlist.h	91;"	d
ANET_CONNECT_NONBLOCK	rnetwork/anet.c	236;"	d	file:
ANET_CONNECT_NONE	rnetwork/anet.c	235;"	d	file:
ANET_ERR	rnetwork/anet.h	35;"	d
ANET_ERR_LEN	rnetwork/anet.h	36;"	d
ANET_H	rnetwork/anet.h	32;"	d
ANET_IP_ONLY	rnetwork/anet.h	40;"	d
ANET_NONE	rnetwork/anet.h	39;"	d
ANET_OK	rnetwork/anet.h	34;"	d
API	vuiint.c	15;"	d	file:
BIG_ENDIAN	rnetwork/config.h	133;"	d
BIG_ENDIAN	rnetwork/config.h	167;"	d
BYTE_ORDER	rnetwork/config.h	140;"	d
BYTE_ORDER	rnetwork/config.h	150;"	d
BYTE_ORDER	rnetwork/config.h	170;"	d
BYTE_ORDER	rnetwork/config.h	172;"	d
GNUC_VERSION	rnetwork/config.h	189;"	d
HAVE_ATOMIC	rnetwork/config.h	191;"	d
HAVE_ATOMIC	rnetwork/config.h	195;"	d
HAVE_BACKTRACE	rnetwork/config.h	60;"	d
HAVE_EPOLL	rnetwork/config.h	65;"	d
HAVE_EVPORT	rnetwork/config.h	75;"	d
HAVE_KQUEUE	rnetwork/config.h	69;"	d
HAVE_MALLOC_SIZE	rnetwork/zmalloc.h	42;"	d
HAVE_MALLOC_SIZE	rnetwork/zmalloc.h	52;"	d
HAVE_MALLOC_SIZE	rnetwork/zmalloc.h	60;"	d
HAVE_PROC_MAPS	rnetwork/config.h	49;"	d
HAVE_PROC_SMAPS	rnetwork/config.h	50;"	d
HAVE_PROC_STAT	rnetwork/config.h	48;"	d
HAVE_SYNC_FILE_RANGE	rnetwork/config.h	93;"	d
HAVE_SYNC_FILE_RANGE	rnetwork/config.h	97;"	d
HAVE_TASKINFO	rnetwork/config.h	55;"	d
INER	vuiint.c	16;"	d	file:
INIT_SETPROCTITLE_REPLACEMENT	rnetwork/config.h	117;"	d
Include	Makefile	/^Include=-Icjson -Irnetwork -Irstr -Irlist `pkg-config --cflags gtk+-3.0`$/;"	m
LITTLE_ENDIAN	rnetwork/config.h	132;"	d
LITTLE_ENDIAN	rnetwork/config.h	164;"	d
LogError	vuirpc.h	11;"	d
LogInfo	vuirpc.h	13;"	d
LogWarn	vuirpc.h	12;"	d
MAX_EVENT_BATCHSZ	rnetwork/ae_evport.c	66;"	d	file:
Mmain	cJSON/test.c	/^int Mmain (int argc, const char * argv[]) {$/;"	f
Objs	Makefile	/^Objs=$(SrcFiles:.c=.o)$/;"	m
PDP_ENDIAN	rnetwork/config.h	134;"	d
PREFIX_SIZE	rnetwork/zmalloc.c	48;"	d	file:
PREFIX_SIZE	rnetwork/zmalloc.c	51;"	d	file:
PREFIX_SIZE	rnetwork/zmalloc.c	53;"	d	file:
REQUEST_POST	client.c	14;"	d	file:
SDS_MAX_PREALLOC	rstr/sds.h	34;"	d
SrcFiles	Makefile	/^SrcFiles=$(wildcard rnetwork\/ae.c rnetwork\/anet.c rnetwork\/zmalloc.c  \\$/;"	m
USE_SETPROCTITLE	rnetwork/config.h	112;"	d
USE_SETPROCTITLE	rnetwork/config.h	116;"	d
ZMALLOC_LIB	rnetwork/zmalloc.h	39;"	d
ZMALLOC_LIB	rnetwork/zmalloc.h	49;"	d
ZMALLOC_LIB	rnetwork/zmalloc.h	65;"	d
_ALL_SOURCE	rnetwork/fmacros.h	40;"	d
_BSD_SOURCE	rnetwork/fmacros.h	33;"	d
_FILE_OFFSET_BITS	rnetwork/fmacros.h	58;"	d
_GNU_SOURCE	rnetwork/fmacros.h	36;"	d
_LARGEFILE_SOURCE	rnetwork/fmacros.h	57;"	d
_POSIX_C_SOURCE	rnetwork/fmacros.h	54;"	d
_REDIS_FMACRO_H	rnetwork/fmacros.h	31;"	d
_XOPEN_SOURCE	rnetwork/fmacros.h	44;"	d
_XOPEN_SOURCE	rnetwork/fmacros.h	50;"	d
__ADLIST_H__	rlist/adlist.h	32;"	d
__AE_H__	rnetwork/ae.h	34;"	d
__CLIENT_H__	client.h	10;"	d
__CONFIG_H	rnetwork/config.h	31;"	d
__NETWORK_H__	network.h	9;"	d
__QUICK_SEARCH_H__	quick_search.h	9;"	d
__SDS_H	rstr/sds.h	32;"	d
__VUIINT_H__	vuiint.h	9;"	d
__VUIRPC_H__	vuirpc.h	9;"	d
__ZMALLOC_H	rnetwork/zmalloc.h	32;"	d
__start_quick_search	vuiint.c	/^INER void *__start_quick_search(void *arg)$/;"	f
__str	rnetwork/zmalloc.h	36;"	d
__xstr	rnetwork/zmalloc.h	35;"	d
_anetTcpServer	rnetwork/anet.c	/^static int _anetTcpServer(char *err, int port, char *bindaddr, int af, int backlog)$/;"	f	file:
_rfds	rnetwork/ae_select.c	/^    fd_set _rfds, _wfds;$/;"	m	struct:aeApiState	file:
_server	vuirpc.h	/^struct _server{$/;"	s
_wfds	rnetwork/ae_select.c	/^    fd_set _rfds, _wfds;$/;"	m	struct:aeApiState	file:
acceptTcpHandler	network.c	/^void acceptTcpHandler(aeEventLoop *el, int fd, void *privdata, int mask) {$/;"	f
addReplay	client.c	/^void addReplay(vuiClient *c, const char *body)$/;"	f
address	cJSON/test.c	/^struct record {const char *precision;double lat,lon;const char *address,*city,*state,*zip,*country; };$/;"	m	struct:record	file:
aeAddMillisecondsToNow	rnetwork/ae.c	/^static void aeAddMillisecondsToNow(long long milliseconds, long *sec, long *ms) {$/;"	f	file:
aeApiAddEvent	rnetwork/ae_epoll.c	/^static int aeApiAddEvent(aeEventLoop *eventLoop, int fd, int mask) {$/;"	f	file:
aeApiAddEvent	rnetwork/ae_evport.c	/^static int aeApiAddEvent(aeEventLoop *eventLoop, int fd, int mask) {$/;"	f	file:
aeApiAddEvent	rnetwork/ae_kqueue.c	/^static int aeApiAddEvent(aeEventLoop *eventLoop, int fd, int mask) {$/;"	f	file:
aeApiAddEvent	rnetwork/ae_select.c	/^static int aeApiAddEvent(aeEventLoop *eventLoop, int fd, int mask) {$/;"	f	file:
aeApiAssociate	rnetwork/ae_evport.c	/^static int aeApiAssociate(const char *where, int portfd, int fd, int mask) {$/;"	f	file:
aeApiCreate	rnetwork/ae_epoll.c	/^static int aeApiCreate(aeEventLoop *eventLoop) {$/;"	f	file:
aeApiCreate	rnetwork/ae_evport.c	/^static int aeApiCreate(aeEventLoop *eventLoop) {$/;"	f	file:
aeApiCreate	rnetwork/ae_kqueue.c	/^static int aeApiCreate(aeEventLoop *eventLoop) {$/;"	f	file:
aeApiCreate	rnetwork/ae_select.c	/^static int aeApiCreate(aeEventLoop *eventLoop) {$/;"	f	file:
aeApiDelEvent	rnetwork/ae_epoll.c	/^static void aeApiDelEvent(aeEventLoop *eventLoop, int fd, int delmask) {$/;"	f	file:
aeApiDelEvent	rnetwork/ae_evport.c	/^static void aeApiDelEvent(aeEventLoop *eventLoop, int fd, int mask) {$/;"	f	file:
aeApiDelEvent	rnetwork/ae_kqueue.c	/^static void aeApiDelEvent(aeEventLoop *eventLoop, int fd, int mask) {$/;"	f	file:
aeApiDelEvent	rnetwork/ae_select.c	/^static void aeApiDelEvent(aeEventLoop *eventLoop, int fd, int mask) {$/;"	f	file:
aeApiFree	rnetwork/ae_epoll.c	/^static void aeApiFree(aeEventLoop *eventLoop) {$/;"	f	file:
aeApiFree	rnetwork/ae_evport.c	/^static void aeApiFree(aeEventLoop *eventLoop) {$/;"	f	file:
aeApiFree	rnetwork/ae_kqueue.c	/^static void aeApiFree(aeEventLoop *eventLoop) {$/;"	f	file:
aeApiFree	rnetwork/ae_select.c	/^static void aeApiFree(aeEventLoop *eventLoop) {$/;"	f	file:
aeApiLookupPending	rnetwork/ae_evport.c	/^static int aeApiLookupPending(aeApiState *state, int fd) {$/;"	f	file:
aeApiName	rnetwork/ae_epoll.c	/^static char *aeApiName(void) {$/;"	f	file:
aeApiName	rnetwork/ae_evport.c	/^static char *aeApiName(void) {$/;"	f	file:
aeApiName	rnetwork/ae_kqueue.c	/^static char *aeApiName(void) {$/;"	f	file:
aeApiName	rnetwork/ae_select.c	/^static char *aeApiName(void) {$/;"	f	file:
aeApiPoll	rnetwork/ae_epoll.c	/^static int aeApiPoll(aeEventLoop *eventLoop, struct timeval *tvp) {$/;"	f	file:
aeApiPoll	rnetwork/ae_evport.c	/^static int aeApiPoll(aeEventLoop *eventLoop, struct timeval *tvp) {$/;"	f	file:
aeApiPoll	rnetwork/ae_kqueue.c	/^static int aeApiPoll(aeEventLoop *eventLoop, struct timeval *tvp) {$/;"	f	file:
aeApiPoll	rnetwork/ae_select.c	/^static int aeApiPoll(aeEventLoop *eventLoop, struct timeval *tvp) {$/;"	f	file:
aeApiResize	rnetwork/ae_epoll.c	/^static int aeApiResize(aeEventLoop *eventLoop, int setsize) {$/;"	f	file:
aeApiResize	rnetwork/ae_evport.c	/^static int aeApiResize(aeEventLoop *eventLoop, int setsize) {$/;"	f	file:
aeApiResize	rnetwork/ae_kqueue.c	/^static int aeApiResize(aeEventLoop *eventLoop, int setsize) {$/;"	f	file:
aeApiResize	rnetwork/ae_select.c	/^static int aeApiResize(aeEventLoop *eventLoop, int setsize) {$/;"	f	file:
aeApiState	rnetwork/ae_epoll.c	/^typedef struct aeApiState {$/;"	s	file:
aeApiState	rnetwork/ae_epoll.c	/^} aeApiState;$/;"	t	typeref:struct:aeApiState	file:
aeApiState	rnetwork/ae_evport.c	/^typedef struct aeApiState {$/;"	s	file:
aeApiState	rnetwork/ae_evport.c	/^} aeApiState;$/;"	t	typeref:struct:aeApiState	file:
aeApiState	rnetwork/ae_kqueue.c	/^typedef struct aeApiState {$/;"	s	file:
aeApiState	rnetwork/ae_kqueue.c	/^} aeApiState;$/;"	t	typeref:struct:aeApiState	file:
aeApiState	rnetwork/ae_select.c	/^typedef struct aeApiState {$/;"	s	file:
aeApiState	rnetwork/ae_select.c	/^} aeApiState;$/;"	t	typeref:struct:aeApiState	file:
aeBeforeSleepProc	rnetwork/ae.h	/^typedef void aeBeforeSleepProc(struct aeEventLoop *eventLoop);$/;"	t
aeCreateEventLoop	rnetwork/ae.c	/^aeEventLoop *aeCreateEventLoop(int setsize) {$/;"	f
aeCreateFileEvent	rnetwork/ae.c	/^int aeCreateFileEvent(aeEventLoop *eventLoop, int fd, int mask,$/;"	f
aeCreateTimeEvent	rnetwork/ae.c	/^long long aeCreateTimeEvent(aeEventLoop *eventLoop, long long milliseconds,$/;"	f
aeDeleteEventLoop	rnetwork/ae.c	/^void aeDeleteEventLoop(aeEventLoop *eventLoop) {$/;"	f
aeDeleteFileEvent	rnetwork/ae.c	/^void aeDeleteFileEvent(aeEventLoop *eventLoop, int fd, int mask)$/;"	f
aeDeleteTimeEvent	rnetwork/ae.c	/^int aeDeleteTimeEvent(aeEventLoop *eventLoop, long long id)$/;"	f
aeEventFinalizerProc	rnetwork/ae.h	/^typedef void aeEventFinalizerProc(struct aeEventLoop *eventLoop, void *clientData);$/;"	t
aeEventLoop	rnetwork/ae.h	/^typedef struct aeEventLoop {$/;"	s
aeEventLoop	rnetwork/ae.h	/^} aeEventLoop;$/;"	t	typeref:struct:aeEventLoop
aeFileEvent	rnetwork/ae.h	/^typedef struct aeFileEvent {$/;"	s
aeFileEvent	rnetwork/ae.h	/^} aeFileEvent;$/;"	t	typeref:struct:aeFileEvent
aeFileProc	rnetwork/ae.h	/^typedef void aeFileProc(struct aeEventLoop *eventLoop, int fd, void *clientData, int mask);$/;"	t
aeFiredEvent	rnetwork/ae.h	/^typedef struct aeFiredEvent {$/;"	s
aeFiredEvent	rnetwork/ae.h	/^} aeFiredEvent;$/;"	t	typeref:struct:aeFiredEvent
aeGetApiName	rnetwork/ae.c	/^char *aeGetApiName(void) {$/;"	f
aeGetFileEvents	rnetwork/ae.c	/^int aeGetFileEvents(aeEventLoop *eventLoop, int fd) {$/;"	f
aeGetSetSize	rnetwork/ae.c	/^int aeGetSetSize(aeEventLoop *eventLoop) {$/;"	f
aeGetTime	rnetwork/ae.c	/^static void aeGetTime(long *seconds, long *milliseconds)$/;"	f	file:
aeMain	rnetwork/ae.c	/^void aeMain(aeEventLoop *eventLoop) {$/;"	f
aeProcessEvents	rnetwork/ae.c	/^int aeProcessEvents(aeEventLoop *eventLoop, int flags)$/;"	f
aeResizeSetSize	rnetwork/ae.c	/^int aeResizeSetSize(aeEventLoop *eventLoop, int setsize) {$/;"	f
aeSearchNearestTimer	rnetwork/ae.c	/^static aeTimeEvent *aeSearchNearestTimer(aeEventLoop *eventLoop)$/;"	f	file:
aeSetBeforeSleepProc	rnetwork/ae.c	/^void aeSetBeforeSleepProc(aeEventLoop *eventLoop, aeBeforeSleepProc *beforesleep) {$/;"	f
aeStop	rnetwork/ae.c	/^void aeStop(aeEventLoop *eventLoop) {$/;"	f
aeTimeEvent	rnetwork/ae.h	/^typedef struct aeTimeEvent {$/;"	s
aeTimeEvent	rnetwork/ae.h	/^} aeTimeEvent;$/;"	t	typeref:struct:aeTimeEvent
aeTimeProc	rnetwork/ae.h	/^typedef int aeTimeProc(struct aeEventLoop *eventLoop, long long id, void *clientData);$/;"	t
aeWait	rnetwork/ae.c	/^int aeWait(int fd, int mask, long long milliseconds) {$/;"	f
anetCreateSocket	rnetwork/anet.c	/^static int anetCreateSocket(char *err, int domain) {$/;"	f	file:
anetDisableTcpNoDelay	rnetwork/anet.c	/^int anetDisableTcpNoDelay(char *err, int fd) $/;"	f
anetEnableTcpNoDelay	rnetwork/anet.c	/^int anetEnableTcpNoDelay(char *err, int fd)$/;"	f
anetGenericAccept	rnetwork/anet.c	/^static int anetGenericAccept(char *err, int s, struct sockaddr *sa, socklen_t *len) {$/;"	f	file:
anetGenericResolve	rnetwork/anet.c	/^int anetGenericResolve(char *err, char *host, char *ipbuf, size_t ipbuf_len,$/;"	f
anetKeepAlive	rnetwork/anet.c	/^int anetKeepAlive(char *err, int fd, int interval)$/;"	f
anetListen	rnetwork/anet.c	/^static int anetListen(char *err, int s, struct sockaddr *sa, socklen_t len, int backlog) {$/;"	f	file:
anetNonBlock	rnetwork/anet.c	/^int anetNonBlock(char *err, int fd)$/;"	f
anetPeerToString	rnetwork/anet.c	/^int anetPeerToString(int fd, char *ip, size_t ip_len, int *port) {$/;"	f
anetRead	rnetwork/anet.c	/^int anetRead(int fd, char *buf, int count)$/;"	f
anetResolve	rnetwork/anet.c	/^int anetResolve(char *err, char *host, char *ipbuf, size_t ipbuf_len) {$/;"	f
anetResolveIP	rnetwork/anet.c	/^int anetResolveIP(char *err, char *host, char *ipbuf, size_t ipbuf_len) {$/;"	f
anetSetError	rnetwork/anet.c	/^static void anetSetError(char *err, const char *fmt, ...)$/;"	f	file:
anetSetReuseAddr	rnetwork/anet.c	/^static int anetSetReuseAddr(char *err, int fd) {$/;"	f	file:
anetSetSendBuffer	rnetwork/anet.c	/^int anetSetSendBuffer(char *err, int fd, int buffsize)$/;"	f
anetSetTcpNoDelay	rnetwork/anet.c	/^static int anetSetTcpNoDelay(char *err, int fd, int val)$/;"	f	file:
anetSockName	rnetwork/anet.c	/^int anetSockName(int fd, char *ip, size_t ip_len, int *port) {$/;"	f
anetTcp6Server	rnetwork/anet.c	/^int anetTcp6Server(char *err, int port, char *bindaddr, int backlog)$/;"	f
anetTcpAccept	rnetwork/anet.c	/^int anetTcpAccept(char *err, int s, char *ip, size_t ip_len, int *port) {$/;"	f
anetTcpConnect	rnetwork/anet.c	/^int anetTcpConnect(char *err, char *addr, int port)$/;"	f
anetTcpGenericConnect	rnetwork/anet.c	/^static int anetTcpGenericConnect(char *err, char *addr, int port, int flags)$/;"	f	file:
anetTcpKeepAlive	rnetwork/anet.c	/^int anetTcpKeepAlive(char *err, int fd)$/;"	f
anetTcpNonBlockConnect	rnetwork/anet.c	/^int anetTcpNonBlockConnect(char *err, char *addr, int port)$/;"	f
anetTcpServer	rnetwork/anet.c	/^int anetTcpServer(char *err, int port, char *bindaddr, int backlog)$/;"	f
anetUnixAccept	rnetwork/anet.c	/^int anetUnixAccept(char *err, int s) {$/;"	f
anetUnixConnect	rnetwork/anet.c	/^int anetUnixConnect(char *err, char *path)$/;"	f
anetUnixGenericConnect	rnetwork/anet.c	/^int anetUnixGenericConnect(char *err, char *path, int flags)$/;"	f
anetUnixNonBlockConnect	rnetwork/anet.c	/^int anetUnixNonBlockConnect(char *err, char *path)$/;"	f
anetUnixServer	rnetwork/anet.c	/^int anetUnixServer(char *err, char *path, mode_t perm, int backlog)$/;"	f
anetV6Only	rnetwork/anet.c	/^static int anetV6Only(char *err, int s) {$/;"	f	file:
anetWrite	rnetwork/anet.c	/^int anetWrite(int fd, char *buf, int count)$/;"	f
aof_fsync	rnetwork/config.h	81;"	d
aof_fsync	rnetwork/config.h	83;"	d
apidata	rnetwork/ae.h	/^    void *apidata; \/* This is used for polling API specific data *\/$/;"	m	struct:aeEventLoop
backlog	vuirpc.h	/^    int backlog;$/;"	m	struct:_server
beforesleep	rnetwork/ae.h	/^    aeBeforeSleepProc *beforesleep;$/;"	m	struct:aeEventLoop
body	client.h	/^    char *body;$/;"	m	struct:request
body	client.h	/^    sds   body;$/;"	m	struct:response
buf	client.h	/^    sds   buf;$/;"	m	struct:response
buf	rstr/sds.h	/^    char buf[];$/;"	m	struct:sdshdr
cJSON	cJSON/cJSON.h	/^typedef struct cJSON {$/;"	s
cJSON	cJSON/cJSON.h	/^} cJSON;$/;"	t	typeref:struct:cJSON
cJSON_AddBoolToObject	cJSON/cJSON.h	132;"	d
cJSON_AddFalseToObject	cJSON/cJSON.h	131;"	d
cJSON_AddItemReferenceToArray	cJSON/cJSON.c	/^void	cJSON_AddItemReferenceToArray(cJSON *array, cJSON *item)						{cJSON_AddItemToArray(array,create_reference(item));}$/;"	f
cJSON_AddItemReferenceToObject	cJSON/cJSON.c	/^void	cJSON_AddItemReferenceToObject(cJSON *object,const char *string,cJSON *item)	{cJSON_AddItemToObject(object,string,create_reference(item));}$/;"	f
cJSON_AddItemToArray	cJSON/cJSON.c	/^void   cJSON_AddItemToArray(cJSON *array, cJSON *item)						{cJSON *c=array->child;if (!item) return; if (!c) {array->child=item;} else {while (c && c->next) c=c->next; suffix_object(c,item);}}$/;"	f
cJSON_AddItemToObject	cJSON/cJSON.c	/^void   cJSON_AddItemToObject(cJSON *object,const char *string,cJSON *item)	{if (!item) return; if (item->string) cJSON_free(item->string);item->string=cJSON_strdup(string);cJSON_AddItemToArray(object,item);}$/;"	f
cJSON_AddNullToObject	cJSON/cJSON.h	129;"	d
cJSON_AddNumberToObject	cJSON/cJSON.h	133;"	d
cJSON_AddStringToObject	cJSON/cJSON.h	134;"	d
cJSON_AddTrueToObject	cJSON/cJSON.h	130;"	d
cJSON_Array	cJSON/cJSON.h	37;"	d
cJSON_CreateArray	cJSON/cJSON.c	/^cJSON *cJSON_CreateArray(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_Array;return item;}$/;"	f
cJSON_CreateBool	cJSON/cJSON.c	/^cJSON *cJSON_CreateBool(int b)					{cJSON *item=cJSON_New_Item();if(item)item->type=b?cJSON_True:cJSON_False;return item;}$/;"	f
cJSON_CreateDoubleArray	cJSON/cJSON.c	/^cJSON *cJSON_CreateDoubleArray(const double *numbers,int count)	{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateNumber(numbers[i]);if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}$/;"	f
cJSON_CreateFalse	cJSON/cJSON.c	/^cJSON *cJSON_CreateFalse(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_False;return item;}$/;"	f
cJSON_CreateFloatArray	cJSON/cJSON.c	/^cJSON *cJSON_CreateFloatArray(const float *numbers,int count)	{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateNumber(numbers[i]);if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}$/;"	f
cJSON_CreateIntArray	cJSON/cJSON.c	/^cJSON *cJSON_CreateIntArray(const int *numbers,int count)		{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateNumber(numbers[i]);if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}$/;"	f
cJSON_CreateNull	cJSON/cJSON.c	/^cJSON *cJSON_CreateNull(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_NULL;return item;}$/;"	f
cJSON_CreateNumber	cJSON/cJSON.c	/^cJSON *cJSON_CreateNumber(double num)			{cJSON *item=cJSON_New_Item();if(item){item->type=cJSON_Number;item->valuedouble=num;item->valueint=(int)num;}return item;}$/;"	f
cJSON_CreateObject	cJSON/cJSON.c	/^cJSON *cJSON_CreateObject(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_Object;return item;}$/;"	f
cJSON_CreateString	cJSON/cJSON.c	/^cJSON *cJSON_CreateString(const char *string)	{cJSON *item=cJSON_New_Item();if(item){item->type=cJSON_String;item->valuestring=cJSON_strdup(string);}return item;}$/;"	f
cJSON_CreateStringArray	cJSON/cJSON.c	/^cJSON *cJSON_CreateStringArray(const char **strings,int count)	{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateString(strings[i]);if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}$/;"	f
cJSON_CreateTrue	cJSON/cJSON.c	/^cJSON *cJSON_CreateTrue(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_True;return item;}$/;"	f
cJSON_Delete	cJSON/cJSON.c	/^void cJSON_Delete(cJSON *c)$/;"	f
cJSON_DeleteItemFromArray	cJSON/cJSON.c	/^void   cJSON_DeleteItemFromArray(cJSON *array,int which)			{cJSON_Delete(cJSON_DetachItemFromArray(array,which));}$/;"	f
cJSON_DeleteItemFromObject	cJSON/cJSON.c	/^void   cJSON_DeleteItemFromObject(cJSON *object,const char *string) {cJSON_Delete(cJSON_DetachItemFromObject(object,string));}$/;"	f
cJSON_DetachItemFromArray	cJSON/cJSON.c	/^cJSON *cJSON_DetachItemFromArray(cJSON *array,int which)			{cJSON *c=array->child;while (c && which>0) c=c->next,which--;if (!c) return 0;$/;"	f
cJSON_DetachItemFromObject	cJSON/cJSON.c	/^cJSON *cJSON_DetachItemFromObject(cJSON *object,const char *string) {int i=0;cJSON *c=object->child;while (c && cJSON_strcasecmp(c->string,string)) i++,c=c->next;if (c) return cJSON_DetachItemFromArray(object,i);return 0;}$/;"	f
cJSON_Duplicate	cJSON/cJSON.c	/^cJSON *cJSON_Duplicate(cJSON *item,int recurse)$/;"	f
cJSON_False	cJSON/cJSON.h	32;"	d
cJSON_GetArrayItem	cJSON/cJSON.c	/^cJSON *cJSON_GetArrayItem(cJSON *array,int item)				{cJSON *c=array->child;  while (c && item>0) item--,c=c->next; return c;}$/;"	f
cJSON_GetArraySize	cJSON/cJSON.c	/^int    cJSON_GetArraySize(cJSON *array)							{cJSON *c=array->child;int i=0;while(c)i++,c=c->next;return i;}$/;"	f
cJSON_GetErrorPtr	cJSON/cJSON.c	/^const char *cJSON_GetErrorPtr(void) {return ep;}$/;"	f
cJSON_GetObjectItem	cJSON/cJSON.c	/^cJSON *cJSON_GetObjectItem(cJSON *object,const char *string)	{cJSON *c=object->child; while (c && cJSON_strcasecmp(c->string,string)) c=c->next; return c;}$/;"	f
cJSON_Hooks	cJSON/cJSON.h	/^typedef struct cJSON_Hooks {$/;"	s
cJSON_Hooks	cJSON/cJSON.h	/^} cJSON_Hooks;$/;"	t	typeref:struct:cJSON_Hooks
cJSON_InitHooks	cJSON/cJSON.c	/^void cJSON_InitHooks(cJSON_Hooks* hooks)$/;"	f
cJSON_IsReference	cJSON/cJSON.h	40;"	d
cJSON_Minify	cJSON/cJSON.c	/^void cJSON_Minify(char *json)$/;"	f
cJSON_NULL	cJSON/cJSON.h	34;"	d
cJSON_New_Item	cJSON/cJSON.c	/^static cJSON *cJSON_New_Item(void)$/;"	f	file:
cJSON_Number	cJSON/cJSON.h	35;"	d
cJSON_Object	cJSON/cJSON.h	38;"	d
cJSON_Parse	cJSON/cJSON.c	/^cJSON *cJSON_Parse(const char *value) {return cJSON_ParseWithOpts(value,0,0);}$/;"	f
cJSON_ParseWithOpts	cJSON/cJSON.c	/^cJSON *cJSON_ParseWithOpts(const char *value,const char **return_parse_end,int require_null_terminated)$/;"	f
cJSON_Print	cJSON/cJSON.c	/^char *cJSON_Print(cJSON *item)				{return print_value(item,0,1);}$/;"	f
cJSON_PrintUnformatted	cJSON/cJSON.c	/^char *cJSON_PrintUnformatted(cJSON *item)	{return print_value(item,0,0);}$/;"	f
cJSON_ReplaceItemInArray	cJSON/cJSON.c	/^void   cJSON_ReplaceItemInArray(cJSON *array,int which,cJSON *newitem)		{cJSON *c=array->child;while (c && which>0) c=c->next,which--;if (!c) return;$/;"	f
cJSON_ReplaceItemInObject	cJSON/cJSON.c	/^void   cJSON_ReplaceItemInObject(cJSON *object,const char *string,cJSON *newitem){int i=0;cJSON *c=object->child;while(c && cJSON_strcasecmp(c->string,string))i++,c=c->next;if(c){newitem->string=cJSON_strdup(string);cJSON_ReplaceItemInArray(object,i,newitem);}}$/;"	f
cJSON_SetIntValue	cJSON/cJSON.h	137;"	d
cJSON_String	cJSON/cJSON.h	36;"	d
cJSON_True	cJSON/cJSON.h	33;"	d
cJSON__h	cJSON/cJSON.h	24;"	d
cJSON_free	cJSON/cJSON.c	/^static void (*cJSON_free)(void *ptr) = free;$/;"	v	file:
cJSON_malloc	cJSON/cJSON.c	/^static void *(*cJSON_malloc)(size_t sz) = malloc;$/;"	v	file:
cJSON_strcasecmp	cJSON/cJSON.c	/^static int cJSON_strcasecmp(const char *s1,const char *s2)$/;"	f	file:
cJSON_strdup	cJSON/cJSON.c	/^static char* cJSON_strdup(const char* str)$/;"	f	file:
callback	client.c	/^struct callback{$/;"	s	file:
calloc	rnetwork/zmalloc.c	60;"	d	file:
calloc	rnetwork/zmalloc.c	65;"	d	file:
child	cJSON/cJSON.h	/^	struct cJSON *child;		\/* An array or object item will have a child pointer pointing to a chain of the items in the array\/object. *\/$/;"	m	struct:cJSON	typeref:struct:cJSON::cJSON
city	cJSON/test.c	/^struct record {const char *precision;double lat,lon;const char *address,*city,*state,*zip,*country; };$/;"	m	struct:record	file:
clientData	rnetwork/ae.h	/^    void *clientData;$/;"	m	struct:aeFileEvent
clientData	rnetwork/ae.h	/^    void *clientData;$/;"	m	struct:aeTimeEvent
clients	vuirpc.h	/^    list *clients;              \/* List of active clients *\/$/;"	m	struct:_server
code	client.h	/^    int   code;$/;"	m	struct:response
country	cJSON/test.c	/^struct record {const char *precision;double lat,lon;const char *address,*city,*state,*zip,*country; };$/;"	m	struct:record	file:
createClient	client.c	/^vuiClient * createClient(int fd)$/;"	f
create_objects	cJSON/test.c	/^void create_objects()$/;"	f
create_reference	cJSON/cJSON.c	/^static cJSON *create_reference(cJSON *item) {cJSON *ref=cJSON_New_Item();if (!ref) return 0;memcpy(ref,item,sizeof(cJSON));ref->string=0;ref->type|=cJSON_IsReference;ref->next=ref->prev=0;return ref;}$/;"	f	file:
csplit	client.c	/^int csplit(char *src, char dim, char **res, int nm)$/;"	f
curc	vuiint.c	/^vuiClient *curc;$/;"	v
diffuse	quick_search.c	/^int diffuse( char *patten, char *string)$/;"	f
direction	rlist/adlist.h	/^    int direction;$/;"	m	struct:listIter
dofile	cJSON/test.c	/^void dofile(char *filename)$/;"	f
doit	cJSON/test.c	/^void doit(char *text)$/;"	f
dup	rlist/adlist.h	/^    void *(*dup)(void *ptr);$/;"	m	struct:list
el	vuirpc.h	/^    aeEventLoop *el;$/;"	m	struct:_server
entry_activate	quick_search.c	/^static void entry_activate(GtkWidget *w, gpointer data){$/;"	f	file:
entry_change	quick_search.c	/^static void entry_change(GtkWidget *w, gpointer data){$/;"	f	file:
entry_init	quick_search.c	/^GtkWidget *entry_init(GtkWidget *list)$/;"	f
ep	cJSON/cJSON.c	/^static const char *ep;$/;"	v	file:
epfd	rnetwork/ae_epoll.c	/^    int epfd;$/;"	m	struct:aeApiState	file:
events	rnetwork/ae.h	/^    aeFileEvent *events; \/* Registered events *\/$/;"	m	struct:aeEventLoop
events	rnetwork/ae_epoll.c	/^    struct epoll_event *events;$/;"	m	struct:aeApiState	typeref:struct:aeApiState::epoll_event	file:
events	rnetwork/ae_kqueue.c	/^    struct kevent *events;$/;"	m	struct:aeApiState	typeref:struct:aeApiState::kevent	file:
evport_debug	rnetwork/ae_evport.c	/^static int evport_debug = 0;$/;"	v	file:
fd	client.h	/^    int fd;$/;"	m	struct:vuiClient
fd	rnetwork/ae.h	/^    int fd;$/;"	m	struct:aeFiredEvent
fd	vuirpc.h	/^    int fd;$/;"	m	struct:_server
finalizerProc	rnetwork/ae.h	/^    aeEventFinalizerProc *finalizerProc;$/;"	m	struct:aeTimeEvent
fired	rnetwork/ae.h	/^    aeFiredEvent *fired; \/* Fired events *\/$/;"	m	struct:aeEventLoop
firstByteMark	cJSON/cJSON.c	/^static const unsigned char firstByteMark[7] = { 0x00, 0x00, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC };$/;"	v	file:
free	rlist/adlist.h	/^    void (*free)(void *ptr);$/;"	m	struct:list
free	rnetwork/zmalloc.c	62;"	d	file:
free	rnetwork/zmalloc.c	67;"	d	file:
free	rstr/sds.h	/^    int free;$/;"	m	struct:sdshdr
freeClient	client.c	/^void freeClient(vuiClient *c) {$/;"	f
free_fn	cJSON/cJSON.h	/^      void (*free_fn)(void *ptr);$/;"	m	struct:cJSON_Hooks
fun	client.c	/^    vuicallback fun;$/;"	m	struct:callback	file:
head	rlist/adlist.h	/^    listNode *head;$/;"	m	struct:list
hex_digit_to_int	rstr/sds.c	/^int hex_digit_to_int(char c) {$/;"	f
hlenght	client.h	/^    int hlenght;$/;"	m	struct:request
host	vuirpc.h	/^    const char *host;$/;"	m	struct:_server
id	rnetwork/ae.h	/^    long long id; \/* time event identifier. *\/$/;"	m	struct:aeTimeEvent
is_hex_digit	rstr/sds.c	/^int is_hex_digit(char c) {$/;"	f
kqfd	rnetwork/ae_kqueue.c	/^    int kqfd;$/;"	m	struct:aeApiState	file:
lastTime	rnetwork/ae.h	/^    time_t lastTime;     \/* Used to detect system clock skew *\/$/;"	m	struct:aeEventLoop
lat	cJSON/test.c	/^struct record {const char *precision;double lat,lon;const char *address,*city,*state,*zip,*country; };$/;"	m	struct:record	file:
len	rlist/adlist.h	/^    unsigned long len;$/;"	m	struct:list
len	rstr/sds.h	/^    int len;$/;"	m	struct:sdshdr
lenght	client.h	/^    int   lenght;$/;"	m	struct:response
lenght	client.h	/^    int lenght;$/;"	m	struct:request
list	rlist/adlist.h	/^typedef struct list {$/;"	s
list	rlist/adlist.h	/^} list;$/;"	t	typeref:struct:list
listAddNodeHead	rlist/adlist.c	/^list *listAddNodeHead(list *list, void *value)$/;"	f
listAddNodeTail	rlist/adlist.c	/^list *listAddNodeTail(list *list, void *value)$/;"	f
listCreate	rlist/adlist.c	/^list *listCreate(void)$/;"	f
listDelNode	rlist/adlist.c	/^void listDelNode(list *list, listNode *node)$/;"	f
listDup	rlist/adlist.c	/^list *listDup(list *orig)$/;"	f
listFirst	rlist/adlist.h	58;"	d
listGetDupMethod	rlist/adlist.h	68;"	d
listGetFree	rlist/adlist.h	69;"	d
listGetIterator	rlist/adlist.c	/^listIter *listGetIterator(list *list, int direction)$/;"	f
listGetMatchMethod	rlist/adlist.h	70;"	d
listIndex	rlist/adlist.c	/^listNode *listIndex(list *list, long index) {$/;"	f
listInsertNode	rlist/adlist.c	/^list *listInsertNode(list *list, listNode *old_node, void *value, int after) {$/;"	f
listIter	rlist/adlist.h	/^typedef struct listIter {$/;"	s
listIter	rlist/adlist.h	/^} listIter;$/;"	t	typeref:struct:listIter
listLast	rlist/adlist.h	59;"	d
listLength	rlist/adlist.h	57;"	d
listNext	rlist/adlist.c	/^listNode *listNext(listIter *iter)$/;"	f
listNextNode	rlist/adlist.h	61;"	d
listNode	rlist/adlist.h	/^typedef struct listNode {$/;"	s
listNode	rlist/adlist.h	/^} listNode;$/;"	t	typeref:struct:listNode
listNodeValue	rlist/adlist.h	62;"	d
listPrevNode	rlist/adlist.h	60;"	d
listRelease	rlist/adlist.c	/^void listRelease(list *list)$/;"	f
listReleaseIterator	rlist/adlist.c	/^void listReleaseIterator(listIter *iter) {$/;"	f
listRewind	rlist/adlist.c	/^void listRewind(list *list, listIter *li) {$/;"	f
listRewindTail	rlist/adlist.c	/^void listRewindTail(list *list, listIter *li) {$/;"	f
listRotate	rlist/adlist.c	/^void listRotate(list *list) {$/;"	f
listSearchKey	rlist/adlist.c	/^listNode *listSearchKey(list *list, void *key)$/;"	f
listSetDupMethod	rlist/adlist.h	64;"	d
listSetFreeMethod	rlist/adlist.h	65;"	d
listSetMatchMethod	rlist/adlist.h	66;"	d
list_append	quick_search.c	/^void list_append(GtkWidget *list, const gchar *str)$/;"	f
list_clear	quick_search.c	/^void list_clear(GtkWidget *list)$/;"	f
list_init	quick_search.c	/^GtkWidget * list_init()$/;"	f
lon	cJSON/test.c	/^struct record {const char *precision;double lat,lon;const char *address,*city,*state,*zip,*country; };$/;"	m	struct:record	file:
main	rstr/sds.c	/^int main(void) {$/;"	f
main	vuirpc.c	/^int main(int argc, char **argv)$/;"	f
malloc	rnetwork/zmalloc.c	59;"	d	file:
malloc	rnetwork/zmalloc.c	64;"	d	file:
malloc_fn	cJSON/cJSON.h	/^      void *(*malloc_fn)(size_t sz);$/;"	m	struct:cJSON_Hooks
mask	rnetwork/ae.h	/^    int mask; \/* one of AE_(READABLE|WRITABLE) *\/$/;"	m	struct:aeFileEvent
mask	rnetwork/ae.h	/^    int mask;$/;"	m	struct:aeFiredEvent
match	rlist/adlist.h	/^    int (*match)(void *ptr, void *key);$/;"	m	struct:list
maxfd	rnetwork/ae.h	/^    int maxfd;   \/* highest file descriptor currently registered *\/$/;"	m	struct:aeEventLoop
method	client.h	/^    const char *method;$/;"	m	struct:request
neterr	vuirpc.h	/^    char neterr[256];$/;"	m	struct:_server
next	cJSON/cJSON.h	/^	struct cJSON *next,*prev;	\/* next\/prev allow you to walk array\/object chains. Alternatively, use GetArraySize\/GetArrayItem\/GetObjectItem *\/$/;"	m	struct:cJSON	typeref:struct:cJSON::cJSON
next	rlist/adlist.h	/^    listNode *next;$/;"	m	struct:listIter
next	rlist/adlist.h	/^    struct listNode *next;$/;"	m	struct:listNode	typeref:struct:listNode::listNode
next	rnetwork/ae.h	/^    struct aeTimeEvent *next;$/;"	m	struct:aeTimeEvent	typeref:struct:aeTimeEvent::aeTimeEvent
npending	rnetwork/ae_evport.c	/^    int     npending;                           \/* # of pending fds *\/$/;"	m	struct:aeApiState	file:
parse_array	cJSON/cJSON.c	/^static const char *parse_array(cJSON *item,const char *value)$/;"	f	file:
parse_hex4	cJSON/cJSON.c	/^static unsigned parse_hex4(const char *str)$/;"	f	file:
parse_number	cJSON/cJSON.c	/^static const char *parse_number(cJSON *item,const char *num)$/;"	f	file:
parse_object	cJSON/cJSON.c	/^static const char *parse_object(cJSON *item,const char *value)$/;"	f	file:
parse_string	cJSON/cJSON.c	/^static const char *parse_string(cJSON *item,const char *str)$/;"	f	file:
parse_value	cJSON/cJSON.c	/^static const char *parse_value(cJSON *item,const char *value)$/;"	f	file:
pending_fds	rnetwork/ae_evport.c	/^    int     pending_fds[MAX_EVENT_BATCHSZ];     \/* pending fds *\/$/;"	m	struct:aeApiState	file:
pending_masks	rnetwork/ae_evport.c	/^    int     pending_masks[MAX_EVENT_BATCHSZ];   \/* pending fds' masks *\/$/;"	m	struct:aeApiState	file:
port	vuirpc.h	/^    int port;$/;"	m	struct:_server
portfd	rnetwork/ae_evport.c	/^    int     portfd;                             \/* event port *\/$/;"	m	struct:aeApiState	file:
precision	cJSON/test.c	/^struct record {const char *precision;double lat,lon;const char *address,*city,*state,*zip,*country; };$/;"	m	struct:record	file:
prev	cJSON/cJSON.h	/^	struct cJSON *next,*prev;	\/* next\/prev allow you to walk array\/object chains. Alternatively, use GetArraySize\/GetArrayItem\/GetObjectItem *\/$/;"	m	struct:cJSON	typeref:struct:cJSON::
prev	rlist/adlist.h	/^    struct listNode *prev;$/;"	m	struct:listNode	typeref:struct:listNode::listNode
print_array	cJSON/cJSON.c	/^static char *print_array(cJSON *item,int depth,int fmt)$/;"	f	file:
print_number	cJSON/cJSON.c	/^static char *print_number(cJSON *item)$/;"	f	file:
print_object	cJSON/cJSON.c	/^static char *print_object(cJSON *item,int depth,int fmt)$/;"	f	file:
print_string	cJSON/cJSON.c	/^static char *print_string(cJSON *item)	{return print_string_ptr(item->valuestring);}$/;"	f	file:
print_string_ptr	cJSON/cJSON.c	/^static char *print_string_ptr(const char *str)$/;"	f	file:
print_value	cJSON/cJSON.c	/^static char *print_value(cJSON *item,int depth,int fmt)$/;"	f	file:
processInputBuffer	client.c	/^void  processInputBuffer(vuiClient *c)$/;"	f
processRequest	client.c	/^void processRequest(vuiClient *c)$/;"	f
processTimeEvents	rnetwork/ae.c	/^static int processTimeEvents(aeEventLoop *eventLoop) {$/;"	f	file:
process_local_tag	vuirpc.c	/^void process_local_tag(vuiClient *c, cJSON *json)$/;"	f
prot	client.h	/^    struct request prot;$/;"	m	struct:vuiClient	typeref:struct:vuiClient::request
querybuf	client.h	/^    sds querybuf;$/;"	m	struct:vuiClient
querymsg	client.h	/^    sds querymsg;$/;"	m	struct:vuiClient
quick_search	quick_search.c	/^void quick_search()  $/;"	f
rdb_fsync_range	rnetwork/config.h	103;"	d
rdb_fsync_range	rnetwork/config.h	105;"	d
readQueryFromClient	client.c	/^void readQueryFromClient(aeEventLoop *el, int fd, void *privdata, int mask) {$/;"	f
realloc	rnetwork/zmalloc.c	61;"	d	file:
realloc	rnetwork/zmalloc.c	66;"	d	file:
reason	client.h	/^    sds   reason;$/;"	m	struct:response
record	cJSON/test.c	/^struct record {const char *precision;double lat,lon;const char *address,*city,*state,*zip,*country; };$/;"	s	file:
redis_fstat	rnetwork/config.h	39;"	d
redis_fstat	rnetwork/config.h	42;"	d
redis_stat	rnetwork/config.h	40;"	d
redis_stat	rnetwork/config.h	43;"	d
request	client.h	/^struct request{$/;"	s
res	client.h	/^    struct response res;$/;"	m	struct:vuiClient	typeref:struct:vuiClient::response
resloveMessage	client.c	/^int resloveMessage(char **msg, vuiClient *c)$/;"	f
resolveHeader	client.c	/^int resolveHeader(sds buf, struct request *prot)$/;"	f
response	client.h	/^struct response{$/;"	s
rfds	rnetwork/ae_select.c	/^    fd_set rfds, wfds;$/;"	m	struct:aeApiState	file:
rfileProc	rnetwork/ae.h	/^    aeFileProc *rfileProc;$/;"	m	struct:aeFileEvent
sds	rstr/sds.h	/^typedef char *sds;$/;"	t
sdsAllocSize	rstr/sds.c	/^size_t sdsAllocSize(sds s) {$/;"	f
sdsIncrLen	rstr/sds.c	/^void sdsIncrLen(sds s, int incr) {$/;"	f
sdsMakeRoomFor	rstr/sds.c	/^sds sdsMakeRoomFor(sds s, size_t addlen) {$/;"	f
sdsRemoveFreeSpace	rstr/sds.c	/^sds sdsRemoveFreeSpace(sds s) {$/;"	f
sdsavail	rstr/sds.h	/^static inline size_t sdsavail(const sds s) {$/;"	f
sdscat	rstr/sds.c	/^sds sdscat(sds s, const char *t) {$/;"	f
sdscatlen	rstr/sds.c	/^sds sdscatlen(sds s, const void *t, size_t len) {$/;"	f
sdscatprintf	rstr/sds.c	/^sds sdscatprintf(sds s, const char *fmt, ...) {$/;"	f
sdscatrepr	rstr/sds.c	/^sds sdscatrepr(sds s, const char *p, size_t len) {$/;"	f
sdscatsds	rstr/sds.c	/^sds sdscatsds(sds s, const sds t) {$/;"	f
sdscatvprintf	rstr/sds.c	/^sds sdscatvprintf(sds s, const char *fmt, va_list ap) {$/;"	f
sdsclear	rstr/sds.c	/^void sdsclear(sds s) {$/;"	f
sdscmp	rstr/sds.c	/^int sdscmp(const sds s1, const sds s2) {$/;"	f
sdscpy	rstr/sds.c	/^sds sdscpy(sds s, const char *t) {$/;"	f
sdscpylen	rstr/sds.c	/^sds sdscpylen(sds s, const char *t, size_t len) {$/;"	f
sdsdup	rstr/sds.c	/^sds sdsdup(const sds s) {$/;"	f
sdsempty	rstr/sds.c	/^sds sdsempty(void) {$/;"	f
sdsfree	rstr/sds.c	/^void sdsfree(sds s) {$/;"	f
sdsfreesplitres	rstr/sds.c	/^void sdsfreesplitres(sds *tokens, int count) {$/;"	f
sdsfromlonglong	rstr/sds.c	/^sds sdsfromlonglong(long long value) {$/;"	f
sdsgrowzero	rstr/sds.c	/^sds sdsgrowzero(sds s, size_t len) {$/;"	f
sdshdr	rstr/sds.h	/^struct sdshdr {$/;"	s
sdsjoin	rstr/sds.c	/^sds sdsjoin(char **argv, int argc, char *sep) {$/;"	f
sdslen	rstr/sds.h	/^static inline size_t sdslen(const sds s) {$/;"	f
sdsmapchars	rstr/sds.c	/^sds sdsmapchars(sds s, const char *from, const char *to, size_t setlen) {$/;"	f
sdsnew	rstr/sds.c	/^sds sdsnew(const char *init) {$/;"	f
sdsnewlen	rstr/sds.c	/^sds sdsnewlen(const void *init, size_t initlen) {$/;"	f
sdsrange	rstr/sds.c	/^void sdsrange(sds s, int start, int end) {$/;"	f
sdssplitargs	rstr/sds.c	/^sds *sdssplitargs(const char *line, int *argc) {$/;"	f
sdssplitlen	rstr/sds.c	/^sds *sdssplitlen(const char *s, int len, const char *sep, int seplen, int *count) {$/;"	f
sdstolower	rstr/sds.c	/^void sdstolower(sds s) {$/;"	f
sdstoupper	rstr/sds.c	/^void sdstoupper(sds s) {$/;"	f
sdstrim	rstr/sds.c	/^sds sdstrim(sds s, const char *cset) {$/;"	f
sdsupdatelen	rstr/sds.c	/^void sdsupdatelen(sds s) {$/;"	f
sendReplay	client.c	/^void sendReplay(aeEventLoop *el, int fd, void *privdata, int mask)$/;"	f
send_replay	vuiint.c	/^API void send_replay(char *rep)$/;"	f
server	vuirpc.c	/^struct _server server;$/;"	v	typeref:struct:_server
setResCode	client.c	/^void setResCode(vuiClient *c, int code, char *reason)$/;"	f
set_code	vuiint.c	/^API void set_code(int code, char *reason)$/;"	f
setsize	rnetwork/ae.h	/^    int setsize; \/* max number of file descriptors tracked *\/$/;"	m	struct:aeEventLoop
skip	cJSON/cJSON.c	/^static const char *skip(const char *in) {while (in && *in && (unsigned char)*in<=32) in++; return in;}$/;"	f	file:
skipspace	client.c	/^const char *skipspace(const char *buf)$/;"	f
skiptospace	client.c	/^const char *skiptospace(const char *buf)$/;"	f
start_quick_search	vuiint.c	/^API void start_quick_search(vuiClient *c)$/;"	f
state	cJSON/test.c	/^struct record {const char *precision;double lat,lon;const char *address,*city,*state,*zip,*country; };$/;"	m	struct:record	file:
stop	rnetwork/ae.h	/^    int stop;$/;"	m	struct:aeEventLoop
string	cJSON/cJSON.h	/^	char *string;				\/* The item's name string, if this item is the child of, or is in the list of subitems of an object. *\/$/;"	m	struct:cJSON
suffix_object	cJSON/cJSON.c	/^static void suffix_object(cJSON *prev,cJSON *item) {prev->next=item;item->prev=prev;}$/;"	f	file:
tail	rlist/adlist.h	/^    listNode *tail;$/;"	m	struct:list
timeEventHead	rnetwork/ae.h	/^    aeTimeEvent *timeEventHead;$/;"	m	struct:aeEventLoop
timeEventNextId	rnetwork/ae.h	/^    long long timeEventNextId;$/;"	m	struct:aeEventLoop
timeProc	rnetwork/ae.h	/^    aeTimeProc *timeProc;$/;"	m	struct:aeTimeEvent
type	cJSON/cJSON.h	/^	int type;					\/* The type of the item, as above. *\/$/;"	m	struct:cJSON
update_zmalloc_stat_add	rnetwork/zmalloc.c	71;"	d	file:
update_zmalloc_stat_add	rnetwork/zmalloc.c	74;"	d	file:
update_zmalloc_stat_add	rnetwork/zmalloc.c	77;"	d	file:
update_zmalloc_stat_alloc	rnetwork/zmalloc.c	91;"	d	file:
update_zmalloc_stat_free	rnetwork/zmalloc.c	101;"	d	file:
update_zmalloc_stat_sub	rnetwork/zmalloc.c	72;"	d	file:
update_zmalloc_stat_sub	rnetwork/zmalloc.c	75;"	d	file:
update_zmalloc_stat_sub	rnetwork/zmalloc.c	83;"	d	file:
url	client.c	/^    const char * url;$/;"	m	struct:callback	file:
url	client.h	/^    const char *url;$/;"	m	struct:request
used_memory	rnetwork/zmalloc.c	/^static size_t used_memory = 0;$/;"	v	file:
used_memory_mutex	rnetwork/zmalloc.c	/^pthread_mutex_t used_memory_mutex = PTHREAD_MUTEX_INITIALIZER;$/;"	v
value	rlist/adlist.h	/^    void *value;$/;"	m	struct:listNode
valuedouble	cJSON/cJSON.h	/^	double valuedouble;			\/* The item's number, if type==cJSON_Number *\/$/;"	m	struct:cJSON
valueint	cJSON/cJSON.h	/^	int valueint;				\/* The item's number, if type==cJSON_Number *\/$/;"	m	struct:cJSON
valuestring	cJSON/cJSON.h	/^	char *valuestring;			\/* The item's string, if type==cJSON_String *\/$/;"	m	struct:cJSON
version	client.h	/^    const char *version;$/;"	m	struct:request
version	client.h	/^    const char *version;$/;"	m	struct:response
vuiClient	client.h	/^typedef struct vuiClient {$/;"	s
vuiClient	client.h	/^} vuiClient;$/;"	t	typeref:struct:vuiClient
vuicallback	client.c	/^typedef void (*vuicallback)(vuiClient *c, cJSON *jon);$/;"	t	file:
vuicallbacks	client.c	/^struct callback vuicallbacks[20] = {$/;"	v	typeref:struct:callback
waiting	client.h	/^    int waiting;$/;"	m	struct:request
wfds	rnetwork/ae_select.c	/^    fd_set rfds, wfds;$/;"	m	struct:aeApiState	file:
wfileProc	rnetwork/ae.h	/^    aeFileProc *wfileProc;$/;"	m	struct:aeFileEvent
when_ms	rnetwork/ae.h	/^    long when_ms; \/* milliseconds *\/$/;"	m	struct:aeTimeEvent
when_sec	rnetwork/ae.h	/^    long when_sec; \/* seconds *\/$/;"	m	struct:aeTimeEvent
window_init	quick_search.c	/^GtkWidget * window_init()$/;"	f
zcalloc	rnetwork/zmalloc.c	/^void *zcalloc(size_t size) {$/;"	f
zfree	rnetwork/zmalloc.c	/^void zfree(void *ptr) {$/;"	f
zip	cJSON/test.c	/^struct record {const char *precision;double lat,lon;const char *address,*city,*state,*zip,*country; };$/;"	m	struct:record	file:
zlibc_free	rnetwork/zmalloc.c	/^void zlibc_free(void *ptr) {$/;"	f
zmalloc	rnetwork/zmalloc.c	/^void *zmalloc(size_t size) {$/;"	f
zmalloc_default_oom	rnetwork/zmalloc.c	/^static void zmalloc_default_oom(size_t size) {$/;"	f	file:
zmalloc_enable_thread_safeness	rnetwork/zmalloc.c	/^void zmalloc_enable_thread_safeness(void) {$/;"	f
zmalloc_get_fragmentation_ratio	rnetwork/zmalloc.c	/^float zmalloc_get_fragmentation_ratio(size_t rss) {$/;"	f
zmalloc_get_private_dirty	rnetwork/zmalloc.c	/^size_t zmalloc_get_private_dirty(void) {$/;"	f
zmalloc_get_rss	rnetwork/zmalloc.c	/^size_t zmalloc_get_rss(void) {$/;"	f
zmalloc_oom_handler	rnetwork/zmalloc.c	/^static void (*zmalloc_oom_handler)(size_t) = zmalloc_default_oom;$/;"	v	file:
zmalloc_set_oom_handler	rnetwork/zmalloc.c	/^void zmalloc_set_oom_handler(void (*oom_handler)(size_t)) {$/;"	f
zmalloc_size	rnetwork/zmalloc.c	/^size_t zmalloc_size(void *ptr) {$/;"	f
zmalloc_size	rnetwork/zmalloc.h	43;"	d
zmalloc_size	rnetwork/zmalloc.h	53;"	d
zmalloc_size	rnetwork/zmalloc.h	61;"	d
zmalloc_thread_safe	rnetwork/zmalloc.c	/^static int zmalloc_thread_safe = 0;$/;"	v	file:
zmalloc_used_memory	rnetwork/zmalloc.c	/^size_t zmalloc_used_memory(void) {$/;"	f
zrealloc	rnetwork/zmalloc.c	/^void *zrealloc(void *ptr, size_t size) {$/;"	f
zstrdup	rnetwork/zmalloc.c	/^char *zstrdup(const char *s) {$/;"	f
